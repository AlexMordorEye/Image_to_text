import cv2 as cv                                                            #импорт библиотеки OpenCV

img = cv.imread('shield.png', cv.IMREAD_GRAYSCALE)                             # грузим наше изображение в код и делаем его серым
h, w = img.shape                                                            # определяем переменные высоты и ширины изображения
res_img = cv.resize(img, (int(w / 10), int(h / 10)), cv.INTER_NEAREST)        # меняем размер изображения и присваеваем его в новую переменную
cv.imshow('Окно', res_img)                                                  # метод для открытия изображения в новом окне
cv.waitKey(1)                                                               # метод для задержки изображения на экране,где 1 и более это кол-во секунд, а 0 - постоянное открытое изображение 

width = res_img.shape[1]                                                    # определяем переменную ширины для уже измененного выше изображения
height = res_img.shape[0]                                                   # определяем переменную высоты для уже измененного выше изображения
x_coordinate = 0                                                            # определяем переменную координаты х со значением 0 (ширина)
y_coordinate = 0                                                            # определяем переменную координаты у со значением 0 (высота)

while x_coordinate in range (width):
    x_coordinate += 1
    nums = []                                                               #Создаем новый список для следующего цикла

    '''По идее следующий цикл должен был менять считывание пикслелей по вертикали ,  но что-то пошло не по плану и я начал мудрить, намудрил настолько что сейчас 
    не до конца понимаю почему оно работает именно так)))
    Как должно работать, если x_coordinate дошел до предела ширины , то y_coordinate должен перешагнуть на следующую строчку пикселей '''

    if x_coordinate == width:                                          
        while y_coordinate in range (height):
            pixel_color = res_img [y_coordinate]
            y_axis_color = []
            y_axis_color.append(pixel_color)
            numsi = y_axis_color[0].tolist()
            strochka = [int(a) for a in numsi]
            ''' Создаем цикл для считывания пикселей.
    Каждый пиксель имеет свой оттенок серого .
    Каждый оттенок имеет свой номер в диапазоне от 0 до 255 значений (где 0 - это черный, 255 - это белый , а все что между ними , градиент серого цвета).
    В цикле каждый символ отвечает за ~ 25 значений оттенка серого,в порядке возрастания.
    Координаты х и у расположены в левом верхнем углу изображения (0,0).
    В условии цикла указано что х может находиться только в диапазоне width(ширина изображеия) .
    Значение оттенка серого можно определить , взяв переменную изображения (res_img) и квадратные скобки , указав в них координаты пикселя по ширине(х) и высоте(у) .
    Каждый раз после выполнения одной из конструкций if в цикле , координата х инкрементирует своё значение на 1 (изменяет свою позицию,двигаясь слева на право на 1 еденицу)
    После того как определили символ он записвыаеться в список. '''
            for pixel_color in strochka:
                if pixel_color in range (0,25):
                    nums.append('  ')
                if pixel_color in range (26,50):
                    nums.append('..')
                if pixel_color in range (51,75):
                    nums.append(',,')
                if pixel_color in range (76,100):
                    nums.append('::')
                if pixel_color in range (101,150):
                    nums.append('aa')
                if pixel_color in range (151,200):
                    nums.append('AA')
                if pixel_color in range (201,255):
                    nums.append('&&')
            
                stroka = ''.join(nums)  # преобразование списка в строку 
            y_coordinate += 1 
            nums = []                   # обнуляем список
            print (stroka)

                
#Кароче тут я сам не совсем понимаю почему именно так он работает )))